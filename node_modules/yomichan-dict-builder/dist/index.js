"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dictionary = void 0;
const jszip_1 = __importDefault(require("jszip"));
const fs_1 = __importDefault(require("fs"));
// Builders
__exportStar(require("./builders/dictionaryIndex"), exports);
__exportStar(require("./builders/termEntry"), exports);
__exportStar(require("./builders/kanjiEntry"), exports);
const path_1 = __importDefault(require("path"));
const dictionaryIndex_1 = require("./builders/dictionaryIndex");
const INDEX_FILE_NAME = 'index.json';
const TERM_BANK_FILE_NAME = (bankNumber) => `term_bank_${bankNumber}.json`;
const TERM_META_BANK_FILE_NAME = (bankNumber) => `term_meta_bank_${bankNumber}.json`;
const KANJI_BANK_FILE_NAME = (bankNumber) => `kanji_bank_${bankNumber}.json`;
const KANJI_META_BANK_FILE_NAME = (bankNumber) => `kanji_meta_bank_${bankNumber}.json`;
const defaultOptions = {
    termBankMaxSize: 10000,
};
class Dictionary {
    constructor(options) {
        this.zip = new jszip_1.default();
        this.stats = {
            termCount: 0,
            termMetaCount: 0,
            kanjiCount: 0,
            kanjiMetaCount: 0,
        };
        this.counters = {
            termBankCount: 1,
            termMetaBankCount: 1,
            kanjiBankCount: 1,
            kanjiMetaBankCount: 1,
        };
        this.termBank = [];
        this.termMetaBank = [];
        this.kanjiBank = [];
        this.kanjiMetaBank = [];
        this.tagBank = [];
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    /**
     * Writes the dictionary index
     * @param index - JSON object
     * @returns
     */
    setIndex(index, directory = './', fileName = 'index.json') {
        return __awaiter(this, void 0, void 0, function* () {
            if (!index.format) {
                index.format = 3;
            }
            yield this.saveJsonToZip(INDEX_FILE_NAME, index);
            if (directory || fileName) {
                const indexBuilder = new dictionaryIndex_1.DictionaryIndex(index);
                yield indexBuilder.export(directory, fileName);
            }
            return this;
        });
    }
    /**
     * Adds a tag
     * @param tag - The tag to add
     */
    addTag(tag) {
        var _a, _b, _c;
        this.tagBank.push([
            tag.name,
            tag.category,
            (_a = tag.sortingOrder) !== null && _a !== void 0 ? _a : 0,
            (_b = tag.notes) !== null && _b !== void 0 ? _b : tag.name,
            (_c = tag.popularityScore) !== null && _c !== void 0 ? _c : 0,
        ]);
        return this;
    }
    /**
     * Saves a tag bank to the zip
     */
    saveTagBank() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tagBank.length === 0)
                return;
            yield this.saveJsonToZip('tag_bank_1.json', this.tagBank);
            this.tagBank = [];
        });
    }
    /**
     * Adds a term to the dictionary
     * @param term - The term to add
     */
    addTerm(term) {
        return __awaiter(this, void 0, void 0, function* () {
            this.termBank.push(term);
            this.stats.termCount++;
            if (this.termBank.length >= this.options.termBankMaxSize) {
                yield this.saveTermBank();
            }
        });
    }
    /**
     * Saves a term bank to the zip
     */
    saveTermBank() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.termBank.length === 0)
                return;
            const { termBankCount } = this.counters;
            yield this.saveJsonToZip(TERM_BANK_FILE_NAME(termBankCount), this.termBank);
            this.termBank = [];
            this.counters.termBankCount++;
        });
    }
    /**
     * Adds a term meta to the dictionary
     * @param meta - The term meta to add
     */
    addTermMeta(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            this.termMetaBank.push(meta);
            this.stats.termMetaCount++;
            if (this.termMetaBank.length >= this.options.termBankMaxSize) {
                yield this.saveTermMetaBank();
            }
        });
    }
    /**
     * Saves a term meta bank to the zip
     */
    saveTermMetaBank() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.termMetaBank.length === 0)
                return;
            const { termMetaBankCount } = this.counters;
            yield this.saveJsonToZip(TERM_META_BANK_FILE_NAME(termMetaBankCount), this.termMetaBank);
            this.termMetaBank = [];
            this.counters.termMetaBankCount++;
        });
    }
    /**
     * Adds a kanji to the dictionary
     * @param kanji - The kanji to add
     */
    addKanji(kanji) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            let array = Array.isArray(kanji)
                ? kanji
                : [
                    kanji.kanji,
                    (_a = kanji.onyomi) !== null && _a !== void 0 ? _a : '',
                    (_b = kanji.kunyomi) !== null && _b !== void 0 ? _b : '',
                    (_c = kanji.tags) !== null && _c !== void 0 ? _c : '',
                    (_d = kanji.meanings) !== null && _d !== void 0 ? _d : [],
                    (_e = kanji.stats) !== null && _e !== void 0 ? _e : {},
                ];
            // If kanji is KanjiInformation array
            this.kanjiBank.push(array);
            this.stats.kanjiCount++;
            if (this.kanjiBank.length >= this.options.termBankMaxSize) {
                yield this.saveKanjiBank();
            }
        });
    }
    /**
     * Accepts an input file and saves it to the dictionary
     * @param inputFilePath - The input file name to save to the dictionary
     */
    addFile(inputFilePath, zipFilePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs_1.default.existsSync(inputFilePath)) {
                throw new Error(`File ${inputFilePath} does not exist.`);
            }
            const file = fs_1.default.readFileSync(inputFilePath);
            this.zip.file(zipFilePath, file);
        });
    }
    /**
     * Saves a kanji bank to the zip
     */
    saveKanjiBank() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.kanjiBank.length === 0)
                return;
            const { kanjiBankCount } = this.counters;
            yield this.saveJsonToZip(KANJI_BANK_FILE_NAME(kanjiBankCount), this.kanjiBank);
            this.kanjiBank = [];
            this.counters.kanjiBankCount++;
        });
    }
    /**
     * Adds a kanji meta to the dictionary
     * @param meta - The kanji meta to add
     */
    addKanjiMeta(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            this.kanjiMetaBank.push(meta);
            this.stats.kanjiMetaCount++;
            if (this.kanjiMetaBank.length >= this.options.termBankMaxSize) {
                yield this.saveKanjiMetaBank();
            }
        });
    }
    /**
     * Saves a kanji meta bank to the zip
     */
    saveKanjiMetaBank() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.kanjiMetaBank.length === 0)
                return;
            const { kanjiMetaBankCount } = this.counters;
            yield this.saveJsonToZip(KANJI_META_BANK_FILE_NAME(kanjiMetaBankCount), this.kanjiMetaBank);
            this.kanjiMetaBank = [];
            this.counters.kanjiMetaBankCount++;
        });
    }
    /**
     * Exports the dictionary to a zip file
     * @param directory - The directory to export the dictionary to
     * @returns The dictionary stats
     */
    export(directory = './') {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { fileName } = this.options;
            if (!fileName) {
                throw new Error('No file name set.');
            }
            // Create directory if it doesn't exist
            if (!fs_1.default.existsSync(directory)) {
                fs_1.default.mkdirSync(directory);
            }
            // Add remaining banks to zip
            yield this.saveTermBank();
            yield this.saveTermMetaBank();
            yield this.saveKanjiBank();
            yield this.saveKanjiMetaBank();
            yield this.saveTagBank();
            const zip = this.zip;
            // Check if index.json present in zip
            const index = yield ((_a = zip.file(INDEX_FILE_NAME)) === null || _a === void 0 ? void 0 : _a.async('string'));
            if (!index) {
                throw new Error('No index file was set.');
            }
            // Write zip to file
            const buffer = yield zip.generateAsync({
                type: 'nodebuffer',
                compression: 'DEFLATE',
                compressionOptions: {
                    level: 9,
                },
            });
            const saveFullPath = path_1.default.join(directory, fileName);
            fs_1.default.writeFileSync(saveFullPath, buffer);
            return this.stats;
        });
    }
    saveJsonToZip(fileName, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = JSON.stringify(data);
            this.zip.file(fileName, json);
        });
    }
}
exports.Dictionary = Dictionary;
